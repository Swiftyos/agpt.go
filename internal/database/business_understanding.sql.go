// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: business_understanding.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const getBusinessUnderstanding = `-- name: GetBusinessUnderstanding :one
SELECT id, user_id, user_name, job_title, business_name, industry, business_size, user_role, key_workflows, daily_activities, pain_points, bottlenecks, manual_tasks, automation_goals, current_software, existing_automation, additional_notes, created_at, updated_at FROM business_understanding WHERE user_id = $1
`

func (q *Queries) GetBusinessUnderstanding(ctx context.Context, userID uuid.UUID) (BusinessUnderstanding, error) {
	row := q.db.QueryRow(ctx, getBusinessUnderstanding, userID)
	var i BusinessUnderstanding
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserName,
		&i.JobTitle,
		&i.BusinessName,
		&i.Industry,
		&i.BusinessSize,
		&i.UserRole,
		&i.KeyWorkflows,
		&i.DailyActivities,
		&i.PainPoints,
		&i.Bottlenecks,
		&i.ManualTasks,
		&i.AutomationGoals,
		&i.CurrentSoftware,
		&i.ExistingAutomation,
		&i.AdditionalNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertBusinessUnderstanding = `-- name: UpsertBusinessUnderstanding :one
INSERT INTO business_understanding (
    user_id,
    user_name,
    job_title,
    business_name,
    industry,
    business_size,
    user_role,
    key_workflows,
    daily_activities,
    pain_points,
    bottlenecks,
    manual_tasks,
    automation_goals,
    current_software,
    existing_automation,
    additional_notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
)
ON CONFLICT (user_id) DO UPDATE SET
    user_name = COALESCE(NULLIF(EXCLUDED.user_name, ''), business_understanding.user_name),
    job_title = COALESCE(NULLIF(EXCLUDED.job_title, ''), business_understanding.job_title),
    business_name = COALESCE(NULLIF(EXCLUDED.business_name, ''), business_understanding.business_name),
    industry = COALESCE(NULLIF(EXCLUDED.industry, ''), business_understanding.industry),
    business_size = COALESCE(NULLIF(EXCLUDED.business_size, ''), business_understanding.business_size),
    user_role = COALESCE(NULLIF(EXCLUDED.user_role, ''), business_understanding.user_role),
    key_workflows = EXCLUDED.key_workflows,
    daily_activities = EXCLUDED.daily_activities,
    pain_points = EXCLUDED.pain_points,
    bottlenecks = EXCLUDED.bottlenecks,
    manual_tasks = EXCLUDED.manual_tasks,
    automation_goals = EXCLUDED.automation_goals,
    current_software = EXCLUDED.current_software,
    existing_automation = EXCLUDED.existing_automation,
    additional_notes = COALESCE(NULLIF(EXCLUDED.additional_notes, ''), business_understanding.additional_notes),
    updated_at = NOW()
RETURNING id, user_id, user_name, job_title, business_name, industry, business_size, user_role, key_workflows, daily_activities, pain_points, bottlenecks, manual_tasks, automation_goals, current_software, existing_automation, additional_notes, created_at, updated_at
`

type UpsertBusinessUnderstandingParams struct {
	UserID             uuid.UUID `json:"user_id"`
	UserName           *string   `json:"user_name"`
	JobTitle           *string   `json:"job_title"`
	BusinessName       *string   `json:"business_name"`
	Industry           *string   `json:"industry"`
	BusinessSize       *string   `json:"business_size"`
	UserRole           *string   `json:"user_role"`
	KeyWorkflows       []byte    `json:"key_workflows"`
	DailyActivities    []byte    `json:"daily_activities"`
	PainPoints         []byte    `json:"pain_points"`
	Bottlenecks        []byte    `json:"bottlenecks"`
	ManualTasks        []byte    `json:"manual_tasks"`
	AutomationGoals    []byte    `json:"automation_goals"`
	CurrentSoftware    []byte    `json:"current_software"`
	ExistingAutomation []byte    `json:"existing_automation"`
	AdditionalNotes    *string   `json:"additional_notes"`
}

func (q *Queries) UpsertBusinessUnderstanding(ctx context.Context, arg UpsertBusinessUnderstandingParams) (BusinessUnderstanding, error) {
	row := q.db.QueryRow(ctx, upsertBusinessUnderstanding,
		arg.UserID,
		arg.UserName,
		arg.JobTitle,
		arg.BusinessName,
		arg.Industry,
		arg.BusinessSize,
		arg.UserRole,
		arg.KeyWorkflows,
		arg.DailyActivities,
		arg.PainPoints,
		arg.Bottlenecks,
		arg.ManualTasks,
		arg.AutomationGoals,
		arg.CurrentSoftware,
		arg.ExistingAutomation,
		arg.AdditionalNotes,
	)
	var i BusinessUnderstanding
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserName,
		&i.JobTitle,
		&i.BusinessName,
		&i.Industry,
		&i.BusinessSize,
		&i.UserRole,
		&i.KeyWorkflows,
		&i.DailyActivities,
		&i.PainPoints,
		&i.Bottlenecks,
		&i.ManualTasks,
		&i.AutomationGoals,
		&i.CurrentSoftware,
		&i.ExistingAutomation,
		&i.AdditionalNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBusinessUnderstanding = `-- name: DeleteBusinessUnderstanding :exec
DELETE FROM business_understanding WHERE user_id = $1
`

func (q *Queries) DeleteBusinessUnderstanding(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBusinessUnderstanding, userID)
	return err
}
